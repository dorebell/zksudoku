// Import the sudoku and crypto libraries 

import puzzle.leo;

// The 'zksudoku' program.
program zksudoku.aleo {

    // We use the one-time-pad as our symmetric encryption algorithm
    function encrypt(key: u32, message: u32) -> u32{
        return key ^ message;
    }

    transition decrypt(key: u32, cipher: u32) -> u32 {
        return key ^ cipher;
    }

    // implements the sudoku atomic swap protocol: given a solved sudoku puzzle 'puzzle' and encryption key 'key',
    // encrypts 'puzzle' with 'key' to get 'cipher', computes the Pedersen64 hash of 'key' to get 'hash', and returns
    // the cipher and hash. The ZK proof generated by leo to check this program verifies that the solution is valid,
    // and that the hash preimage is the key encrypting the solution. 
    transition commit(puzzle: u32, key: u32) -> (u32, field) {
        // Check and prove that the puzzle is valid 
        let puzzle_is_valid: bool = puzzle.leo/check_puzzle(puzzle);
        console.assert_eq(puzzle_is_valid, true);

        let cipher: u32 = encrypt(puzzle, key);

        let hash: field = Pedersen64::hash(key);

        return (cipher, hash);
    }
}
